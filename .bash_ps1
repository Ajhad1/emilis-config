########### aliases ################
## command replacements ##
alias cd='function _f { \cd "$1"/; tree1 --noreport;}; _f' # replace cd with cd then ls
alias cd0='/bin/cd ' # allow cd to be used normally
alias cp0='/bin/cp ' # allows sp to be used normally
alias ls='ls -AhGs --color=auto --group-directories-first --file-type' # auto runs with color
alias ls0='\ls ' # allows ls to be used normally
alias cat0='\cat ' # allows cat to be run normally
alias egrep='egrep --color=auto ' # auto runs with color
alias fgrep='fgrep --color=auto ' # auto runs with color
alias grep='grep --color=auto ' # auto runs with color
alias wget='wget -c ' # auto runs with -c
alias vi='vim ' # always use vim instead of vi
alias vim='vim -c"set number"' # always include line numbers
alias aspell='aspell --dont-backup' # always run in don't backup mode  
alias less='less -R' # always display colors
alias jq='jq -C --tab' # always use color and tabs
alias highlight='highlight -O ansi --force --syntax=sh -n' # always run highlight with color and default syntax
alias tree='tree -ChaDF --du --dirsfirst' # always colorize Tree

### Human readable ###
alias free='free -h' # makes free always human readable
alias df='df -h' # makes df alwaysd human readable
alias du='du -h' # makes du always human readable

## fix typos ##
alias cd..='cd ../' # allows typo to still work
alias cd~='cd ~' # allows typo to still work
alias gittypull='gitttypull' # allows typo to still work
alias gittyadd='gitttyadd' # allows typo to still work
alias gittycommit='gitttycommit' # allows typo to still work
alias gittypush='gitttypush' # allows typo to still work
alias gitttycomit='gitttycommit' # allows typo to still work
alias gittycomit='gitttycommit' # allows typo to still work
alias gitty='gittty' # allows typo to still work
alias pretyprint='jq' # allows typo to stil work
alias printprety='jq' # allows typo to still work

## shortcuts built-in on other commands ##
## alias ..='\cd ../; ls' # allows shortcut for cd ../ ## caused issues
alias ...='\cd ../../; tree1 --noreport' # shortcut for cd ../../
alias ....='\cd ../../../; tree1 --noreport' # shortcut for cd ../../../
alias cdl='function _f { \cd "$1"/; ls;}; _f' # cd then ls
alias cdt='function _f { \cd "$1"/; tree1 --noreport;}; _f' # cd then tree1
alias cdltest='cd_func' # cd then ls
alias cpp='rsync -ahr --info=progress2 ' # use rsync instead of cp for its progress
alias cpp1='rsync -ahr --progress' # Legacy use rsync instead of cp for its progress
# alias ll='ls -lA ' # short cut for long list
alias ll='tree1 -pu' # shortcut for long list with tree
alias mvf='function _mv { mv $@; cd $2; }; _mv' # moves files and cds into it
alias cath='highlight ' # runs highlight instead of cat
alias catj='jq .' # runs jq instead of cat
alias lstest='ls -Alhf --color=auto ' # supposed to be a good ls
alias mkdirf='function _mk { mkdir $1; cd $1; }; _mk' # makes directory and cds into it
alias cdp='cd ~/linux-config/' # changes to linux config directory
alias touchs='function _to { touch "$1"; chmod a+x "$1";}; _to' # create shell script and automatically make executable
alias aspellc='aspell --dont-backup check -C' # always run aspellc with no backup and Camel case
alias tree1='tree -L 1' # Tree to the first level
alias tree2='tree -L 2' # Tree to the second level
alias tree3='tree -L 3' # Tree to the third level
alias psgrep='ps -ef | grep -v grep | grep' # use grep on ps without showing grep 
alias grepps='ps -ef | grep -v grep | grep' # use grep on ps without showing grep
alias grepp='ps -ef | grep -v grep | grep' # use grep on ps without showing grep

### new commands ###
alias getip='curl -s ifconfig.me' # get public ip
alias getlocal='hostname -I' # get local ip
alias getpublic='curl -s ifconfig.me' # get public ip
alias trash='function _t { mkdir --parents ~/.local/share/Trash/files; mv --force -t ~/.local/share/Trash/files "$@"; echo "\"$@\" has been moved to the Trash.";}; _t' # sends to trash instead of deleting
alias s='sudo ' # shortcut to sudo
alias bashreload='reloadbash' # shortcut to shortcut to reload bash
alias gitttypull='git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ pull' # git pull tty
alias gitttyadd='git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ add .' # git add changes tty
alias gitttycommit='git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ add . && git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ commit -m " " --allow-empty-message' # git commit tty
alias gitttypush='updatep && git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ add . && git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ commit -m " " --allow-empty-message && git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/ push && reloadbash' # git push tty
alias gittty='updatep && git --git-dir=$HOME/linux-config/.git --work-tree=$HOME/linux-config/' # auto gets location of tty file
alias common='commonlist | less' # outputs common commands into less
alias editp='vim ~/linux-config/.bash_ps1' # starts editing personlization file
# alias updatep='updatep' # making alias for updatep function

#### actual aliases ####
alias prettyprint='jq' 
alias printpretty='jq'
alias pp='jq'

################ common trying out ##################
alias untar='tar -zxvf ' # shortcut to untar
alias c='clear' # shortcut to clear screen
alias ports='netstat -tulanp ' # shows open ports
alias hists='history | grep ' # searches history

## cover my butt ##
alias mkdir='mkdir -pv ' # always runs mkdir with create parent if needed
alias rm='rm -I --preserve-root ' # do not delete / or prompt if deleting more than 3 files at a time #
alias mv='mv -i ' # always runs in confirmation mode #
alias cp='cp -i ' # always runs in confirmation mode #
alias ln='ln -i ' # always runs in confirmation mode #
alias chown='chown --preserve-root ' # Parenting changing perms on / #
alias chmod='chmod --preserve-root ' # Parenting changing perms on / #
alias chgrp='chgrp --preserve-root ' # Parenting changing perms on / #
alias sudo='sudo ' # always checks commands after sudo for aliases
alias yum='sudo yum ' # auto run yum with sudo
alias apt-get='sudo apt-get ' # always runs apt-get as sudo
alias dnf='sudo dnf ' # always runs dnf as sudo


################# functions #######################
## testing function as alias ##
function cd_func
{
	\cd "$1"; 
	ls; 
} 

## get hosts file and list hosts ##
function hosts
{
	cat /etc/hosts
}

## get terminal name ##
function getSystemInfo
{
	osInfo=$(cat /etc/*release)
	shellName=$(ps -p $$ -o args | tail -n 1)
	terminalParentId=$(ps -p $$ -o ppid | tail -n 1 | sed -e 's/^[[:space:]]*//')
	terminalNameRaw=$(ps -p "$terminalParentId" -o args | tail -n 1 )
	
	if [[ $terminalNameRaw == *"gnome-terminal"* ]]; then
		terminalName="GNOME"
	elif [[ $terminalNameRaw == *"tmux"* ]]; then
		terminalName="TMUX"
	elif [[ $terminalNameRaw == *"sshd"* ]]; then
		terminalName="SSH"
	else	
		terminalName="UNKNOWN"
	fi	
	
	if [[ $osInfo == *"ubunutu"* ]]; then
		osName="UBUNTU"
	elif [[ $osInfo == *"centos"* ]]; then
		osName="CENTOS"
	else
		osName="UNKNOWN"
	fi
}

## reload aliases from .bash_ps1##
function reloadbash
{
	getSystemInfo
	if [[ $osName == "UBUNTU" ]]; then
		if [[ $terminalName == "GNOME" ]]; then
			source ~/.bashrc
		else
			source ~/.bashrc
		fi
	elif [[ $osName == "CENTOS" ]]; then
		if [[ $terminalName == "GNOME" ]]; then
			gnome-terminal --tab --title=newTab
			exit
		else
			source ~/.bashrc
		fi
	else
		if [[ $terminalName == "GNOME" ]]; then
			gnome-terminal --tab --title=newTab
			exit
		else
			source ~/.bashrc
		fi
	fi
}

# Syntax: "repeat [X] [command]"
function repeat      
{
    local i max
    max=$1; shift;
    for ((i=1; i <= max ; i++)); do  # --> C-like syntax
        eval "$@";
    done
}

###### updates personal git stuff ######
function updatep
{
	git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ config user.name "Alejandro Colon"
	git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ config user.email "Alejandro@alejandroc.com"
	git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ remote set-url origin https://ajhad1@github.com/Ajhad1/linux-config.git
}

### returns my most common commands ###
function mycommon
{
	history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl |  head -n10
}

### list common commands ###
function commonlist 
{
	declare -a commandlist=(awk sed git pwd ls cat cp mv mkdir rmdir rm touch find grep sudo df du head tail diff tar chmod chown chgrp kill ping wget uname top history man echo zip unzip hostname useradd userdel)
	declare -a descriplist=()
	for i in ${commandlist[@]}; do
		commandstr=$(whatis $i);
		echo -e $commandstr|sed 's/ -/\n\t-/g';
	done
	echo -e "cd (1)\n\t- Change the shell working directory.;";
	echo -e "jobs (1)\n\t- Display status of jobs. List the active jobs.;";
        echo -e "!* (1)\n\t- Copy previous options and arguments.;";
        echo -e "!! (1)\n\t- Copy complete last command line.;";
}

### calls appropriate extraction tool ###
function extract 
{
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
    return 1
 else
    for n in $@
    do
      if [ -f "$n" ] ; then
          case "${n%,}" in
            *.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar) 
                         tar xvf "$n"       ;;
            *.lzma)      unlzma ./"$n"      ;;
            *.bz2)       bunzip2 ./"$n"     ;;
            *.rar)       unrar x -ad ./"$n" ;;
            *.gz)        gunzip ./"$n"      ;;
            *.zip)       unzip ./"$n"       ;;
            *.z)         uncompress ./"$n"  ;;
            *.7z|*.arj|*.cab|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.rpm|*.udf|*.wim|*.xar)
                         7z x ./"$n"        ;;
            *.xz)        unxz ./"$n"        ;;
            *.exe)       cabextract ./"$n"  ;;
            *)
                         echo "extract: '$n' - unknown archive method"
                         return 1
                         ;;
          esac
      else
          echo "'$n' - file does not exist"
          return 1
      fi
    done
fi
}



################## CLI completion/auto-complete? #############
#### IP completion for connections ####
function _complete_hosts 
{
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    host_list=`{
        for c in /etc/ssh_config /etc/ssh/ssh_config ~/.ssh/config
        do [ -r $c ] && sed -n -e 's/^Host[[:space:]]//p' -e 's/^[[:space:]]*HostName[[:space:]]//p' $c
        done
        for k in /etc/ssh_known_hosts /etc/ssh/ssh_known_hosts ~/.ssh/known_hosts
        do [ -r $k ] && egrep -v '^[#\[]' $k|cut -f 1 -d ' '|sed -e 's/[,:].*//g'
        done
        sed -n -e 's/^[0-9][0-9\.]*//p' /etc/hosts; }|tr ' ' '\n'|grep -v '*'`
    COMPREPLY=( $(compgen -W "${host_list}" -- $cur))
    return 0
}
complete -F _complete_hosts ssh
complete -F _complete_hosts sshs
complete -F _complete_hosts host
complete -F _complete_hosts telnet
complete -F _complete_hosts ping

## DSCONFIG CLI completion ##
function _complete_ds
{
	dspath=$(find / -name "dsconfig" -mount 2>/dev/null | tail -n 1)
	## dspath=$(locate /bin/dsconfig | tail -n 1)
	if [ ! -z "$dspath" ] ; then
		commandlist=$($dspath --help-all | grep '^[a-z].*')
		printf "$commandlist"
		return 0
	fi
}
## dspath=$(locate /bin/dsconfig | tail -n 1)
dspath=$(find / -name "dsconfig" -mount 2>/dev/null | tail -n 1)
if [ ! -z "$dspath" ] ; then
	complete -W "$(_complete_ds)" dsconfig
fi


################### customization for the command prompt #################

#### code to input separator ####
# Fill with minuses
# (this is recalculated every time the prompt is shown in function prompt_command):
fill="--- "

reset_style='\[\033[00m\]'
if [ -z "$VIM" ];
	then status_style=$reset_style'\[\033[0;90m\]' # gray color; use 0;37m for lighter color
else status_style=$reset_style'\[\033[0;90;107m\]'
fi
prompt_style=$reset_style
command_style=$reset_style'\[\033[1;29m\]' # bold black
# Prompt variable:

## OLD_PS1="$PS1"
## NEW_PS1='$fill HN: $hostnameVar DIR: $pwdVar UN: $name \t \n'
## if [[ ${#NEW_PS1} -gt ${COLUMNS} ]] ; then
##     columns=${COLUMNS}
##     NEW_PS1='$columns $fill DIR: $pwdVar UN: $name \t \n'
## fi
## if [[ ! $PS1 == *'$name'* ]] ; then
##     PS1="$status_style""$NEW_PS1""$prompt_style$OLD_PS1$command_style"
## fi
## 
## # Reset color for command output
## # (this one is invoked every time before a command is executed):
## trap 'echo -ne "\e[0m"' DEBUG

function prompt_command {

    # create a $fill of all screen width minus the time string and a space and USER and a space:
    name=$(fc -l -1 | awk -v u="$USER" '{if ($2=="sudo") { if ($3=="-u") u=$4; else u="root"; }; printf "%s",u}')
    if [[ $name == "" ]] ; then
        nameVar=""
    else
        nameVar="UN: $name | "
    fi
    pwdVar="DIR: $(pwd) | "
    hostnameVar="HN: $(hostname) | "
    let fillsize=${COLUMNS}-11-${#nameVar}-${#pwdVar}-${#hostnameVar}
    fill=""
    while [ "$fillsize" -gt "0" ]
    do
        fill="-${fill}" # fill with underscores to work on 
        let fillsize=${fillsize}-1
    done    

    NEW_NEW_PS1="${fill} ${hostnameVar}${pwdVar}${nameVar}XX:XX:XX"
    if [[ ${#NEW_NEW_PS1} -gt ${COLUMNS} ]] ; then
        let fillsize=${COLUMNS}-11-${#nameVar}-${#pwdVar}
        fill=""
        while [ "$fillsize" -gt "0" ]
        do
             fill="-${fill}" # fill with underscores to work 
             let fillsize=${fillsize}-1
        done
        hostnameVar=""
    fi
	
    # If this is an xterm set the title to user@host:dir
    case "$TERM" in
    xterm*|rxvt*)
        bname=`basename "${PWD/$HOME/~}"`
        echo -ne "\033]0;${bname}: ${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"
        ;;
    *)
        ;;
    esac
  
}
OLD_PROMPT_COMMAND=PROMPT_COMMAND
NEW_PROMPT_COMMAND=prompt_command
if [[ ! $OLD_PROMPT_COMMAND == $NEW_PROMPT_COMMAND ]] ; then
	PROMPT_COMMAND=prompt_command
fi

OLD_PS1="$PS1"
NEW_PS1='${fill} ${hostnameVar}${pwdVar}${nameVar}\t\n'
## if [[ ${#NEW_PS1} -gt $columns ]] ; then
##     columns1=$columns
##     NEW_PS1='$columns1 $fill DIR: $pwdVar UN: $name \t \n'
## fi
if [[ ! $PS1 == *'${nameVar}'* ]] ; then
    PS1="$status_style""$NEW_PS1""$prompt_style$OLD_PS1$command_style"
fi

# Reset color for command output
# (this one is invoked every time before a command is executed):
trap 'echo -ne "\e[0m"' DEBUG


### my personal settings ###
force_color_prompt=yes             # add color to terminals
HISTCONTROL=ignoreboth # don't put duplicate lines or lines starting with space in the history.
shopt -s checkwinsize     # check the window size after each command and, if necessary, update the values of LINES and COLUMNS.

####### load my newest personalization file on TTY load ##########
getSystemInfo
prompt_command && prompt_command && echo -e "${fill} ${hostnameVar}${pwdVar}${nameVar}$(date +'%T')"
echo "Pulling latest personalization file from remote repository. "
printf "______Status:_____ " && git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ pull # pull on load
echo "Comparing local personalization file to remote in git."
git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ add . > /dev/null && git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ commit -m " " --allow-empty-message --short > /dev/null # adds and commits any changes
printf "_____Changes:_____ " && echo -e $(git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ status --short) # get status on load
echo "If local changes push using gitttypush"
git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ config user.name "Alejandro Colon"
git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ config user.email "Alejandro@alejandroc.com"
git  --git-dir=$HOME/linux-config/.git  --work-tree=$HOME/linux-config/ remote set-url origin https://ajhad1@github.com/Ajhad1/linux-config.git
prompt_command && echo -e "${fill} ${hostnameVar}${pwdVar}${nameVar}$(date +'%T')"
echo "_____Public IP:    _____ $(getip)"
echo "_____Private IP(s):_____ $(hostname -I)"
echo "_____FQDN(s):      _____ $(hostname -A)"
echo "_____OS:           _____ $osName"
echo "_____Terminal:     _____ $terminalName"
prompt_command && echo -e "${fill} ${hostnameVar}${pwdVar}${nameVar}$(date +'%T')"
echo "_____Current Directory:_____ $(pwd)"
## prompt_command && echo -e "${fill} ${hostnameVar}${pwdVar}${nameVar}$(date +'%T')"
tree1 --noreport
## ls -AhG --color=auto --group-directories-first --file-type
